### zshプロンプト設定

# カラーの設定を$fg[red]のように人がわかるような書き方ができる
autoload -Uz colors
colors

# $WINDOWなどの環境変数をプロンプトに設定するために使用
setopt prompt_subst

## コマンド実行後右プロンプトを消す
#setopt transient_rprompt


#
# Color定義(あとで変更しやすいように)
#
DEFAULT=$'%{\e[0;0m%}'
RESET="%{${reset_color}%}"
GREEN="%{${fg[green]}%}"
BOLD_GREEN="%{${fg_bold[green]}%}"
BLUE="%{${fg[blue]}%}"
BOLD_BLUE="%{${fg_bold[blue]}%}"
RED="%{${fg[red]}%}"
BOLD_RED="%{${fg_bold[red]}%}"
CYAN="%{${fg[cyan]}%}"
BOLD_CYAN="%{${fg_bold[cyan]}%}"
YELLOW="%{${fg[yellow]}%}"
BOLD_YELLOW="%{${fg_bold[yellow]}%}"
MAGENTA="%{${fg[magenta]}%}"
BOLD_MAGENTA="%{${fg_bold[magenta]}%}"
WHITE="%{${fg[white]}%}"


## Set prompt for zsh
#
# PROMPT  : 通常のプロンプト
# PROMPT2 : forやwhile文使用時の複数行入力プロンプト
# RPROMPT : 右側に表示されるプロンプト, 入力が被ると自動的に消える
# SPROMPT : 入力ミス時のコマンド訂正プロンプト
#
# コマンド訂正プロンプト
#  y: 訂正コマンドを実行
#  n: 入力したコマンドが実行
#  a: 実行を中断 abort
#  e: コマンドライン編集 edit
#
# プロンプト文字列
#   %% : %文字
#   %# : #文字(一般ユーザなら %，スーパユーザなら #)
#   %l : tty名
#   %M : ホスト名（全部）
#   %m : ホスト名（最初のドットまで）
#   %n : ユーザ名
#   %? : 直前のコマンドの終了値($?)
#   %/ : カレントディレクトリ(フルパス)
#   %~ : 同上,ただし~記号などで可能な限り短縮する
#   %1~ or %1/ : カレントディレクトリ(ベースネーム)
#   %B : 太字開始
#   %b : 太字解除
#   %(1j,(%j),) : 実行中のジョブ数が1つ以上ある場合ジョブ数を表示
#
#   %{%(?.$fg[white].$fg[red])%}
#    直前の終了ステータスに応じてプロンプトの色が変化(0:白, 0以外:赤)
#    http://blog.8-p.info/2009/01/red-prompt
#
#   %D{%Y/%m/%d %H:%M:%S} : 時間表示(年/月/日 時:分:秒)
#
#   %(5~,%-2~/.../%2~,%~)%<space> : 長いディレクトリ名を省略表示
#
#   $WINDOW : screen 実行時のスクリーン番号
#
case ${UID} in
0)
    ## rootユーザの場合(全て赤文字)
    #   su - or sudo -s を行った場合環境変数が引き継がれないためSSH接続の判定が行えない

    PROMPT="${RESET}${BOLD_RED}[%n@%m:%~]#$RESET} "
    PROMPT2="${RESET}${BOLD_RED}%_${RESET} "
    SPROMPT="${RESET}${RED}%r is correct? [n,y,a,e]:${RESET} "
    ;;
*)
    ## 一般ユーザの場合
    #

    # SSH接続時
    #  HostのIPを環境変数に設定
    #  http://d.hatena.ne.jp/kakurasan/20070611/p1
    if [ -n "${SSH_CONNECTION}" ]; then
        export HOST_IP=$(echo ${SSH_CONNECTION} | awk -F\  '{printf "SSH("$1")"}')
    fi

    #
    # tmuxのウィンドウ番号とペイン番号を環境変数に設定
    #
    _set_tmux_window() {
        if [ "$TMUX" ]; then
            #export TMUX_WINDOW=$(tmux list-windows 2> /dev/null | awk -F: '/\(active\)$/ {printf $1}')"-"$(tmux list-panes 2> /dev/null | awk -F: '/\(active\)$/ {printf $1}')

            # tmux display
            #   -p 標準出力へ
            #   -t 対象のペイン番号($TMUX_PANEなどを指定)
            export TMUX_WINDOW=$(tmux display -p '#I-#P')
        fi
    }
    add-zsh-hook precmd _set_tmux_window


    ## For zsh-git-prompt
    if [ -f ~/.zsh/zsh-git-prompt/zshrc.sh ]; then
        source ~/.zsh/zsh-git-prompt/zshrc.sh
    fi


    #
    # Prompt
    #
    DEFAULT_PROMPT='${RESET}${BOLD_YELLOW}${HOST_IP:+"${HOST_IP}>"}${RESET}[${BOLD_BLUE}${WINDOW:+"#$WINDOW "}${TMUX_WINDOW:+"$TMUX_WINDOW "}${RESET}${BOLD_GREEN}%n${RESET}${GREEN}❖ ${RESET}${BOLD_GREEN}%m${RESET}${RED}%(1j,(%j),)${RESET}:${CYAN}%~${RESET}]%{%(?.$fg[blue].$fg[red])%}♪  ${RESET}'

    # For tmux-powerline
    DEFAULT_PROMPT="$DEFAULT_PROMPT"'$([ -n "$TMUX" ] && tmux setenv TMUXPWD_$(tmux display -p "#I_#P") "$PWD")'

    VI_CMD_PROMPT='${RESET}${BOLD_YELLOW}${HOST_IP:+"${HOST_IP}>"}${RESET}[${BOLD_BLUE}${WINDOW:+"#$WINDOW "}${TMUX_WINDOW:+"$TMUX_WINDOW "}${RESET}${YELLOW}%n@%m${RESET}${RED}%(1j,(%j),)${RESET}:${CYAN}%~${RESET}]%{%(?.$fg[white].$fg[red])%}$ ${RESET}'

    PROMPT=${DEFAULT_PROMPT}
    SPROMPT="${RESET}${RED}%r is correct? [n,y,a,e]:${RESET} "

    #
    # Vi入力モードでPROMPTの色を変える
    # http://memo.officebrook.net/20090226.html
    #
    function zle-line-init zle-keymap-select {
        case $KEYMAP in
        vicmd)
            # viコマンドモード
            PROMPT=${VI_CMD_PROMPT}
            ;;
        main|viins)
            # viインサートモード
            PROMPT=${DEFAULT_PROMPT}
            ;;
        esac
        zle reset-prompt
    }
    zle -N zle-line-init
    zle -N zle-keymap-select


    #
    # Gitの状態表示
    #  http://d.hatena.ne.jp/mollifier/20100906/p1
    #  http://d.hatena.ne.jp/yuroyoro/20110219/1298089409
    #  http://d.hatena.ne.jp/pasela/20110216/git_not_pushed
    #  http://liosk.blog103.fc2.com/blog-entry-209.html
    #  http://zsh.sourceforge.net/Doc/Release/User-Contributions.html#SEC273
    #
    # 記号について
    #   - : WorkingTreeに変更がある場合(Indexにaddしていない変更がある場合)
    #   + : Indexに変更がある場合(commitしていない変更がIndexにある場合)
    #   ? : Untrackedなファイルがある場合
    #   * : remoteにpushしていない場合
    #
    autoload -Uz vcs_info

    zstyle ':vcs_info:*' enable git svn hg bzr
    zstyle ':vcs_info:*' formats '(%s)-[%b]'
    zstyle ':vcs_info:*' actionformats '(%s)-[%b|%a]'
    zstyle ':vcs_info:(svn|bzr):*' branchformat '%b:r%r'
    zstyle ':vcs_info:bzr:*' use-simple true

    autoload -Uz is-at-least
    if is-at-least 4.3.10; then
        # zshが4.3.10以上の場合
        zstyle ':vcs_info:git:*' check-for-changes true
        zstyle ':vcs_info:git:*' stagedstr "+"
        zstyle ':vcs_info:git:*' unstagedstr "-"
        zstyle ':vcs_info:git:*' formats '%s,%u%c,%b'
        zstyle ':vcs_info:git:*' actionformats '%s,%u%c,%b|%a'
    fi

    function _update_vcs_info_msg() {
        # zsh-git-prompt
        if type git_super_status >/dev/null 2>&1; then
            RPROMPT="${RESET}$(git_super_status)${RESET}${BOLD_YELLOW}${VIRTUAL_ENV:+($(basename "$VIRTUAL_ENV"))}${RESET}[${MAGENTA}%D{%Y/%m/%d %H:%M:%S}${RESET}]${RESET}"
            return 0
        fi

        # zsh-git-promptが使用できない場合
        psvar=()
        LANG=en_US.UTF-8 vcs_info
        local _vcs_name _status  _branch_action
        if [ -n "$vcs_info_msg_0_" ]; then
            _vcs_name=$(echo "$vcs_info_msg_0_" | cut -d , -f 1)
            _status=$(_git_untracked_or_not_pushed $(echo "$vcs_info_msg_0_" | cut -d , -f 2))
            _branch_action=$(echo "$vcs_info_msg_0_" | cut -d , -f 3)
            psvar[1]="(${_vcs_name})-[${_status}${_branch_action}]"
        fi
        # 右側プロンプト
        RPROMPT="${RESET}%1(v|${RED}%1v|)${RESET}${BOLD_YELLOW}${VIRTUAL_ENV:+($(basename "$VIRTUAL_ENV"))}${RESET}[${MAGENTA}%D{%Y/%m/%d %H:%M:%S}${RESET}]${RESET}"
    }
    add-zsh-hook precmd _update_vcs_info_msg

    #
    # Untrackedなファイルが存在するか未PUSHなら記号を出力
    #   Untracked: ?
    #   未PUSH: *
    #
    function _git_untracked_or_not_pushed() {
        local git_status head remotes stagedstr
        local  staged_unstaged=$1 not_pushed="*" untracked="?"
        # カレントがgitレポジトリ下かどうか判定
        if [ "$(git rev-parse --is-inside-work-tree 2> /dev/null)" = "true" ]; then
            # statusをシンプル表示で取得
            git_status=$(git status -s 2> /dev/null)
            # git status -s の先頭が??で始まる行がない場合、Untrackedなファイルは存在しない
            if ! echo "$git_status" | grep -q "^??"; then
                untracked=""
            fi

            # stagedstrを取得
            zstyle -s ":vcs_info:git:*" stagedstr stagedstr
            # stagedな新規ファイルがvcs_infoで検出されない(only Initial commit)
            #  git status -s で先頭がAで始まる行がstagedな新規ファイル
            if [ -n "$stagedstr" ] \
                && ! printf "$staged_unstaged" | fgrep -q "$stagedstr" \
                && echo "$git_status" | grep -q "^A"; then
                staged_unstaged=${staged_unstaged}${stagedstr}
            fi

            # HEADのハッシュ値を取得
            #  --verify 有効なオブジェクト名として使用できるかを検証
            #  --quiet  --verifyと共に使用し、無効なオブジェクトが指定された場合でもエラーメッセージを出さない
            #           そのかわり終了ステータスを0以外にする
            head=$(git rev-parse --verify -q HEAD 2> /dev/null)
            if [ $? -eq 0 ]; then
                # HEADのハッシュ値取得に成功
                # リモートのハッシュ値を配列で取得
                remotes=($(git rev-parse --remotes 2> /dev/null))
                if [ "$remotes[*]" ]; then
                    # リモートのハッシュ値取得に成功(リモートが存在する)
                    for x in ${remotes[@]}; do
                        # リモートとHEADのハッシュ値が一致するか判定
                        if [ "$head" = "$x" ]; then
                            # 一致した場合はPUSH済み
                            not_pushed=""
                            break
                        fi
                    done
                else
                    # リモートが存在しない場合
                    not_pushed=""
                fi
            else
                # HEADが存在しない場合(init直後など)
                not_pushed=""
            fi

            # Untrackedなファイルが存在するか未PUSHなら記号を出力
            if [ -n "$staged_unstaged" -o -n "$untracked" -o -n "$not_pushed" ]; then
                printf "${staged_unstaged}${untracked}${not_pushed}"
            fi
        fi
        return 0
    }
    ;;
esac

# vim: ft=zsh
